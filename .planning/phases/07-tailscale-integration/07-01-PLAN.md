---
phase: 07-tailscale-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - scripts/bootstrap.sh
  - docker-compose.yaml
  - scripts/connect-mac-node.sh
autonomous: true
user_setup:
  - service: tailscale
    why: "Tailscale Serve provides HTTPS for Control UI and off-LAN access"
    env_vars:
      - name: TS_AUTHKEY
        source: "Tailscale Admin -> Settings -> OAuth clients -> Create client (scope: auth_keys write, tag: tag:server). Copy the tskey-client-... secret."
    dashboard_config:
      - task: "Create Tailscale account"
        location: "https://login.tailscale.com (free tier, up to 100 devices)"
      - task: "Create tag:server ACL tag"
        location: "Tailscale Admin -> Access Controls -> add tag:server"
      - task: "Enable MagicDNS"
        location: "Tailscale Admin -> DNS -> Enable MagicDNS"
      - task: "Add TS_AUTHKEY to Coolify env"
        location: "Coolify -> openclaw service -> Environment Variables -> add TS_AUTHKEY=tskey-client-..."
      - task: "Install Tailscale on MacBook"
        location: "brew install --cask tailscale, then login with same Tailscale account"

must_haves:
  truths:
    - "Tailscale binaries (tailscale + tailscaled) exist in the Docker image"
    - "tailscaled starts before openclaw gateway in bootstrap.sh"
    - "openclaw.json has gateway.bind=loopback and tailscale.mode=serve"
    - "Temp patches (mode=remote, remote.url, remote.token, --allow-unconfigured) are removed"
    - "useAccessGroups=false patch is preserved"
    - "connect-mac-node.sh uses Tailscale MagicDNS URL instead of LAN IP"
    - "TS_AUTHKEY is passed through docker-compose.yaml from Coolify env"
  artifacts:
    - path: "Dockerfile"
      provides: "tailscale-install stage with pinned v1.94.2 binaries"
      contains: "tailscale/tailscale:v1.94.2"
    - path: "scripts/bootstrap.sh"
      provides: "tailscaled startup sequence + config patches + temp patch removal"
      contains: "tailscaled --tun=userspace-networking"
    - path: "docker-compose.yaml"
      provides: "TS_AUTHKEY and TS_HOSTNAME env vars for openclaw service"
      contains: "TS_AUTHKEY"
    - path: "scripts/connect-mac-node.sh"
      provides: "Updated MacBook connection script using Tailscale URL"
      contains: "ts.net"
  key_links:
    - from: "Dockerfile"
      to: "scripts/bootstrap.sh"
      via: "tailscale + tailscaled binaries available in PATH"
      pattern: "COPY --from=docker.io/tailscale/tailscale"
    - from: "scripts/bootstrap.sh"
      to: "openclaw gateway"
      via: "tailscaled started and connected BEFORE exec openclaw gateway run"
      pattern: "tailscaled.*&.*tailscale up.*exec openclaw"
    - from: "docker-compose.yaml"
      to: "scripts/bootstrap.sh"
      via: "TS_AUTHKEY env var passed through"
      pattern: "TS_AUTHKEY"
---

<objective>
Add Tailscale Serve to the OpenClaw container so the gateway is accessible via HTTPS from anywhere on the tailnet. This fixes the Control UI "requires secure context" error, enables off-LAN access, and removes the temporary gateway.mode=remote patches from bootstrap.sh.

Purpose: Control UI currently broken (needs HTTPS). Tailscale Serve provides automatic HTTPS with valid TLS certs via MagicDNS. This also removes 4 temporary patches that were workarounds for sub-agent spawning.
Output: Modified Dockerfile, bootstrap.sh, docker-compose.yaml, connect-mac-node.sh ready for deploy.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-tailscale-integration/07-RESEARCH.md
@Dockerfile
@scripts/bootstrap.sh
@docker-compose.yaml
@scripts/connect-mac-node.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tailscale-install Dockerfile stage and update docker-compose.yaml</name>
  <files>Dockerfile, docker-compose.yaml</files>
  <action>
**Dockerfile changes:**

Add a new build stage `tailscale-install` between `openclaw-install` and `final`. This stage copies the tailscale and tailscaled binaries from the official Tailscale Docker image (pinned to v1.94.2). The final stage must then build FROM tailscale-install instead of openclaw-install.

Exact changes:

1. After the `openclaw-install` stage (after line 152), add:

```dockerfile
# Stage 3.5: Tailscale binaries (cached — only rebuilds when version changes)
# Binary copy pattern from tailscale.com/kb/1107/heroku — no APT repo needed
FROM openclaw-install AS tailscale-install

ARG TAILSCALE_VERSION=1.94.2
COPY --from=docker.io/tailscale/tailscale:v1.94.2 /usr/local/bin/tailscaled /usr/local/bin/tailscaled
COPY --from=docker.io/tailscale/tailscale:v1.94.2 /usr/local/bin/tailscale /usr/local/bin/tailscale
RUN mkdir -p /var/run/tailscale /var/cache/tailscale /var/lib/tailscale
```

2. Change the final stage FROM line (currently `FROM openclaw-install AS final`) to:
```dockerfile
FROM tailscale-install AS final
```

3. Update the comment above final stage to reflect the new stage numbering:
```dockerfile
# Stage 5: Final application stage (changes on every git push)
```

**docker-compose.yaml changes:**

Add TS_AUTHKEY and TS_HOSTNAME environment variables to the openclaw service. These are read by bootstrap.sh for tailscale authentication.

1. In the openclaw service environment section, after the `OPENCLAW_BETA` line (line 114), add:
```yaml
      # Tailscale (Phase 7)
      TS_AUTHKEY: ${TS_AUTHKEY:-}
      TS_HOSTNAME: ${TS_HOSTNAME:-openclaw-server}
```

2. Change `OPENCLAW_GATEWAY_BIND: lan` (line 68) to:
```yaml
      OPENCLAW_GATEWAY_BIND: loopback
```

3. The `ports: ["18789:18789"]` line can stay — it becomes vestigial with bind=loopback but is harmless. Add a comment:
```yaml
    ports:
      - "18789:18789"  # Vestigial with bind=loopback — Tailscale Serve handles access
```

Do NOT add cap_add, devices, or /dev/net/tun — tailscale will use userspace networking (--tun=userspace-networking) which requires no special capabilities.
  </action>
  <verify>
Run `grep -n 'tailscale-install\|tailscale/tailscale\|TS_AUTHKEY\|GATEWAY_BIND.*loopback' Dockerfile docker-compose.yaml` to confirm:
- Dockerfile has the tailscale-install stage with v1.94.2
- Dockerfile final stage builds FROM tailscale-install
- docker-compose.yaml has TS_AUTHKEY and TS_HOSTNAME
- docker-compose.yaml has OPENCLAW_GATEWAY_BIND: loopback
  </verify>
  <done>
Dockerfile has a new tailscale-install stage between openclaw-install and final. Final stage builds from tailscale-install. docker-compose.yaml passes TS_AUTHKEY and TS_HOSTNAME to the container and sets OPENCLAW_GATEWAY_BIND to loopback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update bootstrap.sh — tailscaled startup, config patches, temp patch removal</name>
  <files>scripts/bootstrap.sh</files>
  <action>
This task makes three categories of changes to bootstrap.sh.

**IMPORTANT: Executor must re-read bootstrap.sh (using the Read tool) after completing each category before starting the next.** Line numbers shift after edits. Do NOT rely on line numbers from the initial read for categories B or C. Re-read, find the correct insertion/deletion points, then apply.

**CATEGORY A: Add tailscaled startup sequence (insert BEFORE the `exec openclaw gateway run` line)**

Insert the following block after the "Banner & Access Info" section and before the final `exec openclaw` line. The block starts tailscaled, authenticates with TS_AUTHKEY, and waits for connection:

```bash
# ----------------------------
# Tailscale Startup (Phase 7)
# ----------------------------
# OpenClaw with tailscale.mode=serve requires tailscaled running and authenticated.
# Uses userspace networking — no NET_ADMIN cap or /dev/net/tun needed.
# State persisted to /data/tailscale/ (existing volume) to survive restarts.
if command -v tailscaled >/dev/null 2>&1; then
  TS_STATE="/data/tailscale"
  mkdir -p "$TS_STATE"
  tailscaled --tun=userspace-networking \
    --statedir="$TS_STATE" \
    --socket=/var/run/tailscale/tailscaled.sock \
    >/tmp/tailscaled.log 2>&1 &
  TAILSCALED_PID=$!
  echo "[tailscale] Started tailscaled (PID $TAILSCALED_PID, userspace networking)"

  # Wait for socket to be available (up to 10s)
  for i in $(seq 1 10); do
    [ -S /var/run/tailscale/tailscaled.sock ] && break
    sleep 1
  done

  # Brief pause after socket appears — daemon may not be fully ready yet
  sleep 1

  # Verify daemon is responsive before proceeding
  tailscale --socket=/var/run/tailscale/tailscaled.sock status >/dev/null 2>&1 || echo "[tailscale] WARNING: tailscaled socket exists but daemon not yet responsive"

  # Authenticate (idempotent — skips if already logged in from persisted state)
  if [ -n "${TS_AUTHKEY:-}" ]; then
    tailscale --socket=/var/run/tailscale/tailscaled.sock up \
      --auth-key="${TS_AUTHKEY}" \
      --hostname="${TS_HOSTNAME:-openclaw-server}" \
      --accept-routes 2>&1 || echo "[tailscale] WARNING: tailscale up failed (may already be authenticated)"
  fi

  # Wait for tailscale to be connected (up to 30s)
  TS_READY=false
  for i in $(seq 1 15); do
    if tailscale --socket=/var/run/tailscale/tailscaled.sock status --json 2>/dev/null \
        | jq -e '.BackendState == "Running"' >/dev/null 2>&1; then
      TS_IP=$(tailscale --socket=/var/run/tailscale/tailscaled.sock ip -4 2>/dev/null || true)
      TS_READY=true
      echo "[tailscale] Connected to tailnet (IP: ${TS_IP:-unknown})"
      break
    fi
    sleep 2
  done
  if [ "$TS_READY" = "false" ]; then
    echo "[tailscale] WARNING: tailscale not connected after 30s — gateway may fail with tailscale.mode=serve"
  fi

  # Log tailscale serve status for diagnostics (helps debug if openclaw's serve call fails later)
  echo "[tailscale] Serve status at startup:"
  tailscale --socket=/var/run/tailscale/tailscaled.sock serve status 2>&1 || echo "[tailscale] WARNING: tailscale serve status check failed — userspace-networking may require SOCKS5 proxy config for serve. Check /tmp/tailscaled.log"
fi
```

**After applying Category A, re-read bootstrap.sh before proceeding to Category B.**

**CATEGORY B: Update openclaw.json config patches (in the existing jq patch block)**

1. CHANGE the gateway.bind from "lan" to "loopback" in the initial config template (the `cat >"$CONFIG_FILE"` heredoc). Find `"bind": "lan"` and change to `"bind": "loopback"`. Also change `"mode": "off"` to `"mode": "serve"` in the tailscale section.

2. Add a new idempotent patch after the existing patches (after the `useAccessGroups=false` patch) that ensures bind=loopback and tailscale.mode=serve on existing configs:

```bash
  # Patch: gateway.bind=loopback + tailscale.mode=serve (Phase 7)
  # bind=loopback means gateway only listens on 127.0.0.1 — Tailscale Serve proxies HTTPS
  CURRENT_BIND=$(jq -r '.gateway.bind // empty' "$CONFIG_FILE" 2>/dev/null)
  if [ "$CURRENT_BIND" != "loopback" ]; then
    jq '.gateway.bind = "loopback"' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
    echo "[config] Set gateway.bind=loopback (Tailscale Serve handles external access)"
  fi
  CURRENT_TS_MODE=$(jq -r '.gateway.tailscale.mode // empty' "$CONFIG_FILE" 2>/dev/null)
  if [ "$CURRENT_TS_MODE" != "serve" ]; then
    jq '.gateway.tailscale = {"mode": "serve", "resetOnExit": false}' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
    echo "[config] Set gateway.tailscale.mode=serve"
  fi
```

**After applying Category B, re-read bootstrap.sh before proceeding to Category C.**

**CATEGORY C: Remove temp patches (4 removals)**

1. DELETE the `gateway.remote.url` patch block (lines 333-338 in current file):
```
  # Patch: gateway.remote.url — sub-agents use loopback to bypass plaintext LAN security check
  REMOTE_URL=...
  ...
  fi
```

2. DELETE the `gateway.mode=remote` patch block (lines 339-346):
```
  # TEMP: set gateway.mode=remote so sub-agents resolve via remote.url (loopback)
  ...
  fi
```

3. DELETE the `gateway.remote.token` patch block (lines 347-356):
```
  # TEMP: set gateway.remote.token so sub-agents can auth when mode=remote
  ...
  fi
```

4. CHANGE the final exec line from:
```bash
exec openclaw gateway run --allow-unconfigured
```
to:
```bash
exec openclaw gateway run
```

5. DELETE the comment above it:
```bash
# TEMP: --allow-unconfigured required when gateway.mode=remote without full remote config
# Remove when CHANGELOG #22582 ships.
```

6. Also add a cleanup patch that removes stale gateway.mode and gateway.remote from existing configs on volume (in the jq patch block, after the new tailscale patches):

```bash
  # Cleanup: remove stale temp patches from volume config (Phase 7)
  if jq -e '.gateway.mode == "remote"' "$CONFIG_FILE" &>/dev/null; then
    jq '.gateway.mode = "local"' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
    echo "[config] Reverted gateway.mode from remote to local (temp patch removed)"
  fi
  if jq -e '.gateway.remote != null' "$CONFIG_FILE" &>/dev/null; then
    jq 'del(.gateway.remote)' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
    echo "[config] Removed gateway.remote (temp patch removed)"
  fi
```

**IMPORTANT: Preserve these existing patches unchanged:**
- `commands.useAccessGroups = false` (separate issue)
- `del(.gateway.dangerouslyDisableDeviceAuth)` (safety cleanup)
- `del(.commands.gateway) | del(.commands.restart)` (safety cleanup)
- All memorySearch, subagent model, heartbeat, imageModel, fallback patches
- The openclaw symlink restoration guard at the top

**Update the banner section** to reflect the new access pattern:
Change the echo lines near the end to include Tailscale info:
```bash
echo "Onboarding:"
echo "  1. View credentials: cat $ACCESS_FILE"
echo "  2. Access Control UI: https://\${TS_HOSTNAME:-openclaw-server}.[tailnet].ts.net"
echo "  3. Approve this machine: openclaw-approve"
echo "  4. Start onboarding: openclaw onboard"
```
  </action>
  <verify>
1. `grep -n 'tailscaled --tun=userspace-networking' scripts/bootstrap.sh` — confirms tailscaled startup added
2. `grep -n 'gateway.mode.*remote\|gateway.remote.url\|gateway.remote.token\|--allow-unconfigured' scripts/bootstrap.sh` — should return ZERO results (all temp patches removed)
3. `grep -n 'bind.*loopback\|tailscale.mode.*serve\|useAccessGroups.*false' scripts/bootstrap.sh` — confirms new patches and preserved patches
4. `grep -c 'TEMP:.*remove when CHANGELOG' scripts/bootstrap.sh` — should return 0
5. `grep -n 'sleep 1' scripts/bootstrap.sh` — confirms post-socket-ready pause exists in tailscale block
6. `grep -n 'tailscale.*status.*dev.null\|daemon not yet responsive' scripts/bootstrap.sh` — confirms daemon responsiveness check after socket loop
7. `grep -n 'tailscale.*serve status' scripts/bootstrap.sh` — confirms serve status diagnostic logging
  </verify>
  <done>
bootstrap.sh starts tailscaled before openclaw gateway, patches openclaw.json to bind=loopback + tailscale.mode=serve, removes all 4 temp patches (mode=remote, remote.url, remote.token, --allow-unconfigured), and preserves useAccessGroups=false and all other existing patches. Tailscale startup includes: socket readiness wait, 1s post-socket pause, daemon responsiveness check, and serve status diagnostic logging.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update connect-mac-node.sh for Tailscale MagicDNS URL</name>
  <files>scripts/connect-mac-node.sh</files>
  <action>
Update the MacBook browser control script to use the Tailscale MagicDNS HTTPS URL instead of the LAN IP. With bind=loopback, the LAN IP (192.168.1.100:18789) will no longer work — the MacBook MUST use the Tailscale URL.

**IMPORTANT: Before writing the script, run `openclaw node run --help 2>&1 | head -30` to determine the correct flag syntax.** If `openclaw` is not installed locally, SSH into the server and run it inside the container:
```bash
sshpass -p '@pack86N5891' ssh -o StrictHostKeyChecking=no ameer@192.168.1.100 \
  "CONTAINER=\$(sudo docker ps --format '{{.Names}}' | grep openclaw | head -1) && sudo docker exec \$CONTAINER openclaw node run --help 2>&1 | head -30"
```

Look for flags matching `--url`, `--host`, `--port`, `--tls`, `--gateway-url`, or similar. Use the actual flags found.

Replace the entire script with this updated version that:
1. Uses the Tailscale HTTPS URL as default gateway
2. Allows override via environment variable for flexibility
3. Adds a connectivity check before attempting connection
4. Dynamically determines the correct flag at runtime

Key changes:
- `GATEWAY_HOST="192.168.1.100"` becomes `GATEWAY_URL="${OPENCLAW_GATEWAY_URL:-https://openclaw-server}"` (user fills in their tailnet suffix)
- The `openclaw node run` command adapts to whichever flag is available
- Add a note about finding the correct MagicDNS URL

The script should be:

```bash
#!/usr/bin/env bash
# Start OpenClaw browser control on this Mac.
# Connects to the gateway via Tailscale HTTPS, starts the Chrome extension relay, opens Chrome.
# Ctrl+C to stop everything.
#
# Prerequisites:
#   1. Tailscale installed and logged in on this Mac (brew install --cask tailscale)
#   2. Same Tailscale account as the server
#   3. Find your URL: tailscale status (look for openclaw-server)
#
# Usage:
#   ./connect-mac-node.sh                                    # uses default URL
#   GATEWAY_URL=https://openclaw-server.tailnet-name.ts.net ./connect-mac-node.sh  # custom URL

set -e

# Default: MagicDNS URL — user must update the tailnet name on first use
GATEWAY_URL="${GATEWAY_URL:-https://openclaw-server.CHANGE-ME.ts.net}"

if [[ "$GATEWAY_URL" == *"CHANGE-ME"* ]]; then
  echo "ERROR: Update GATEWAY_URL with your tailnet name."
  echo ""
  echo "Find it by running: tailscale status"
  echo "Look for the machine named 'openclaw-server' and use its full MagicDNS name."
  echo ""
  echo "Example:"
  echo "  GATEWAY_URL=https://openclaw-server.tail12345.ts.net $0"
  echo ""
  echo "Or edit this script and replace CHANGE-ME with your tailnet name."
  exit 1
fi

cleanup() {
  echo ""
  echo "Shutting down node host..."
  kill "$NODE_PID" 2>/dev/null || true
  wait "$NODE_PID" 2>/dev/null || true
  echo "Done."
}
trap cleanup EXIT INT TERM

# 1. Verify Tailscale is connected
if ! tailscale status >/dev/null 2>&1; then
  echo "ERROR: Tailscale is not running or not logged in."
  echo "Install: brew install --cask tailscale"
  echo "Then open Tailscale.app and login."
  exit 1
fi

# 2. Determine correct flag for gateway URL
# openclaw node run may use --url, --gateway-url, --host/--port, or other flags
NODE_HELP=$(openclaw node run --help 2>&1 || true)
if echo "$NODE_HELP" | grep -qE '\-\-url\b'; then
  NODE_CMD=(openclaw node run --url "$GATEWAY_URL" --node-id my-macbook --display-name "MacBook Pro")
elif echo "$NODE_HELP" | grep -qE '\-\-gateway-url\b'; then
  NODE_CMD=(openclaw node run --gateway-url "$GATEWAY_URL" --node-id my-macbook --display-name "MacBook Pro")
elif echo "$NODE_HELP" | grep -qE '\-\-host\b'; then
  # Extract hostname from URL for --host flag
  GW_HOST=$(echo "$GATEWAY_URL" | sed 's|https://||;s|/.*||')
  NODE_CMD=(openclaw node run --host "$GW_HOST" --port 443 --tls --node-id my-macbook --display-name "MacBook Pro")
else
  echo "WARNING: Could not determine correct flag from 'openclaw node run --help'."
  echo "Trying --url (most likely). If this fails, run 'openclaw node run --help' and update this script."
  NODE_CMD=(openclaw node run --url "$GATEWAY_URL" --node-id my-macbook --display-name "MacBook Pro")
fi

# 3. Start node host in background
echo "Connecting to gateway at $GATEWAY_URL..."
echo "  Using command: ${NODE_CMD[*]}"
"${NODE_CMD[@]}" &
NODE_PID=$!

# 4. Wait for node to connect and relay to start
sleep 3

# 5. Start browser relay (one-shot — starts relay, exits OK if tab not yet attached)
echo "Starting Chrome extension relay..."
openclaw browser start 2>/dev/null || true

# 6. Open Chrome
echo "Opening Chrome..."
open -a "Google Chrome"

echo ""
echo "---"
echo "  Gateway: $GATEWAY_URL"
echo "  Click the OpenClaw extension icon on any tab"
echo "  Then ask the bot to use your browser"
echo "---"
echo ""
echo "Press Ctrl+C to disconnect."

# 7. Keep alive
wait "$NODE_PID"
```
  </action>
  <verify>
1. `grep -n 'GATEWAY_URL\|ts.net\|tailscale' scripts/connect-mac-node.sh` — confirms Tailscale URL usage
2. `grep -n '192.168.1.100' scripts/connect-mac-node.sh` — should return ZERO results (LAN IP removed)
3. `grep -n 'node run --help' scripts/connect-mac-node.sh` — confirms runtime flag detection logic is present
  </verify>
  <done>
connect-mac-node.sh uses Tailscale MagicDNS HTTPS URL instead of LAN IP. Includes CHANGE-ME guard so user is prompted to set their tailnet name. Verifies Tailscale is running before connecting. Dynamically detects the correct openclaw node run flag (--url, --gateway-url, or --host/--port) at runtime.
  </done>
</task>

</tasks>

<verification>
After all three tasks complete, verify the full change set:

1. **Dockerfile stage order:** base -> runtimes -> browser-deps -> openclaw-install -> tailscale-install -> final
2. **No temp patches remain:** `grep -r 'allow-unconfigured\|mode.*remote\|remote.url\|remote.token' scripts/bootstrap.sh` returns nothing
3. **Tailscale startup present:** `grep 'tailscaled --tun=userspace-networking' scripts/bootstrap.sh` returns a match
4. **Config patches correct:** `grep 'bind.*loopback\|tailscale.mode.*serve' scripts/bootstrap.sh` returns matches
5. **useAccessGroups preserved:** `grep 'useAccessGroups.*false' scripts/bootstrap.sh` returns a match
6. **LAN IP gone from MacBook script:** `grep '192.168.1.100' scripts/connect-mac-node.sh` returns nothing
7. **TS_AUTHKEY in docker-compose:** `grep 'TS_AUTHKEY' docker-compose.yaml` returns a match
8. **Socket readiness hardening:** `grep 'sleep 1' scripts/bootstrap.sh` within tailscale block, `grep 'daemon not yet responsive' scripts/bootstrap.sh`
9. **Serve status diagnostic:** `grep 'tailscale.*serve status' scripts/bootstrap.sh` returns a match
10. **Runtime flag detection:** `grep 'node run --help' scripts/connect-mac-node.sh` returns a match
</verification>

<success_criteria>
- Dockerfile builds with tailscale-install stage (tailscale + tailscaled binaries from v1.94.2)
- bootstrap.sh starts tailscaled with userspace networking, authenticates, waits for ready, then starts openclaw
- Tailscale startup includes socket readiness pause (sleep 1), daemon responsiveness check, and serve status diagnostic logging
- openclaw.json is patched to gateway.bind=loopback + tailscale.mode=serve on every boot
- All 4 temp patches removed (mode=remote, remote.url, remote.token, --allow-unconfigured)
- useAccessGroups=false and all other existing patches preserved
- docker-compose.yaml passes TS_AUTHKEY and TS_HOSTNAME to container
- connect-mac-node.sh uses Tailscale MagicDNS URL with runtime flag detection
- No references to LAN IP 192.168.1.100 remain in connect-mac-node.sh
</success_criteria>

<output>
After completion, create `.planning/phases/07-tailscale-integration/07-01-SUMMARY.md`
</output>
